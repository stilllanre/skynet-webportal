include /etc/nginx/conf.d/include/cors;
include /etc/nginx/conf.d/include/proxy-buffer;
include /etc/nginx/conf.d/include/proxy-cache-downloads;
include /etc/nginx/conf.d/include/track-download;

# redirect purge calls to separate location
error_page 462 = @purge;
if ($request_method = PURGE) {
    return 462;
}

limit_conn downloads_by_ip 100; # ddos protection: max 100 downloads at a time

# $skylink_v1 and $skylink_v2 variables default to the same value but in case the requested skylink was:
# a) skylink v1 - it wouldn't matter, no additional logic is executed
# b) skylink v2 - in a lua block below we will resolve the skylink v2 into skylink v1 and update 
#      $skylink_v1 variable so then the proxy request to skyd can be cached in nginx (proxy_cache_key 
#      in proxy-cache-downloads includes $skylink_v1 as a part of the cache key)
set $skylink_v1 $skylink;
set $skylink_v2 $skylink;

# variable for Skynet-Proof header that we need to inject 
# into a response if the request was for skylink v2
set $skynet_proof '';



header_filter_by_lua_block {
    -- not empty skynet_proof means this is a skylink v2 request
    -- so we should replace the Skynet-Proof header with the one
    -- we got from /skynet/resolve/ endpoint, otherwise we would
    -- be serving cached empty v1 skylink Skynet-Proof header
    if ngx.var.skynet_proof then
        ngx.header["Skynet-Proof"] = ngx.var.skynet_proof
    end
}

proxy_read_timeout 600;
proxy_set_header User-Agent: Sia-Agent;

# in case the requested skylink was v2 and we already resolved it to skylink v1, we're going to pass resolved 
# skylink v1 to skyd to save that extra skylink v2 lookup in skyd but in turn, in case skyd returns a redirect 
# we need to rewrite the skylink v1 to skylink v2 in the location header with proxy_redirect
proxy_redirect $skylink_v1 $skylink_v2;
proxy_pass http://sia:9980/skynet/skylink/$skylink_v1$path$is_args$args;